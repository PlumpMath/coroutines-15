/*
 * Реализация сопрограмм (coroutines) на Си.
 *
 * Использует инлайн-ассемблер GCC для amd64. Не использует setjmp/longjmp, swapcontext и прочее.
 *
 * Реализован планировщик round-robin и функция yield
 * (без передачи параметров или выбора переключаемой сопрограммы)
 *
*/
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <malloc.h>

/* Дескриптор сопрограммы.
 *
 * Структуры taskstate образуют циклический список.
 * Каждый элемент в нем соответствует одной сопрограмме.
 *
 * Список содержит по меньшей мере одну сопрограмму (исходный поток выполнения процесса),
 * в которой выполняется coroutine_mainloop(). Эта сопрограмма использует исходный стек.
 * Стеки для остальных сопрограмм выделяются с помощью malloc.
 */
struct taskstate {
    /* значения регистров сохраняются в момент переключения с этой сопрограммы на другую в функции yield() */
    char *rsp; /* сохраненное значение регистра rsp */
    char *rbp; /* сохраненное значение регистра rbp */
    /* Остальное состояние сопрограммы будет восстановлено из стека.
     * Казалось бы, надо бы сохранить еще счетчик инструкций rip, чтобы было откуда продолжать работу?
     * На самом деле это не нужно, т.к. переключение сопрограмм происходит в строго определенном месте - 
     * в середине функции yield, вызываемой из кода сопрограммы.
     */

    /* блок памяти, содержащий стек сопрограммы (возвращенный функцией malloc указатель) */
    char *allocated_stack;
    /* указатель на следующую сопрограмму в циклическом списке */
    struct taskstate *next;
};

/* "голова" циклического списка сопрограмм -
 * дескриптор сопрограммы, выполняющейся в данный момент.
 */
struct taskstate *__current_task = NULL;

/* API для работы с сопрограммами. */
void yield();  /* переключение на следующую сопрограмму */
void coroutine_exit();  /* завершение текущей сопрограммы (с освобождением памяти под стек) */
void coroutine_init();  /* инициализация циклического списка сопрограмм */
void coroutine_schedule(void (*)); /* вызов функции в виде новой сопрограммы (выделение стека, добавление в список) */
void coroutine_mainloop(); /* планировщик сопрограмм (выполняется, пока есть хотя бы одна сопрограмма) */


/* Завершение текущей сопрограммы.
 *
 * Вызывается автоматически при выходе из функции, переданной в coroutine_schedule.
 *
 * Но можно вызвать и вручную в произвольном месте в стеке вызовов (сработает как выброс исключения)
 */
void coroutine_exit() {
    struct taskstate *oldtask = __current_task; /* дескриптор сопрограммы, которую хотим завершить */
    struct taskstate *prevtask = __current_task; /* ищем предыдущую по списку сопрограмму */
    while (prevtask->next != oldtask) prevtask = prevtask->next;

    if (prevtask == oldtask || oldtask->allocated_stack == NULL) {
        printf("Tried to free last coroutine!");
        exit(1);
    }
    /* извлекаемся из списка */
    prevtask->next = oldtask->next;

    /* Освобождаем память под стек и дескриптор сопрограммы.
     *
     * Эта память еще будет использоваться - до середины функции yield,
     * где произойдет переключение на новый стек и дескриптор.
     * Поэтому обнулять память сразу же нельзя.
     */
    free(oldtask->allocated_stack);
    free(oldtask);
    /* Переключаемся на следующую сопрограмму.
     *
     * Следующая будет определена по next текущего дескриптора
     * (да, того самого, память под который мы только что освободили)
     */
    yield();
    /* Из этой функции мы уже не вернемся, т.к. стек будет переключен. */
    printf("Unreachable code!\n");
}

/* Вызов функции в виде сопрограммы.
 *
 * Подготавливается стек для новой сопрограммы.
 * Дескриптор добавляется в начало циклического списка сопрограмм.
 * Новая сопрограмма будет вызвана при очередном вызове yield().
 */
void coroutine_schedule(void (*coro)) {
    int stacksize = 16*1024; /* размер стека для сопрограммы в байтах */
    char *newstackbase = malloc(stacksize);
    void **newptr = (void **)(newstackbase + stacksize); /* стек, как известно, растет в сторону уменьшения адресов */
    /* Идея следующая: сейчас особым образом подготовим стек сопрограммы,
     * затем вызовем yield,
     * он переключится на этот стек и "продолжит" выполнение сопрограммы.
     * Сопрограмма выполняется, выполняется... и в конечном счете должна передать управление в 
     * функцию coroutine_exit, где мы освободим ресурсы, выделенные под сопрогамму (то есть память под стек и дескриптор).
     *
     * Значит, нам надо подготовить стек таким образом, как будто
     *  - из функции coroutine_exit мы вызвали нашу сопрограмму coro (а значит из нее должны вернуться в coroutine_exit);
     *  - из coro вызвали yield (а значит из yield вернемся в coro);
     *  - половина функции yield отработала (т.к. переключение происходит в середине).
     *
     *  Нужно заметить, что код, подготавливающий стек, одинаков для x86 и amd64 (только размер указателей разный).
     *  Для не-Intel архитектур, возможно, стек организуется по-другому.
    */

    /* поместим в стек адреса возврата: */
    *(--newptr) = coroutine_exit; /* сюда вернемся при возврате из coro */
    *(--newptr) = coro;           /* сюда вернемся при возврате из yield */

    /* Компилятор Си вставляет в конец функции инструкцию leave, которая эквивалентна коду
     *     mov rsp, rbp
     *     pop rbp
     * Соответственно нам надо сэмулировать push rbp...
    */
    *(--newptr) = (void *)0xDEADBEEF; /* old ebp: нам не сильно важно, какое значение rbp будет восстановлено.
                                     Ведь мы сразу после ret попадем в начало coro, где rbp будет установлен заново...
                                  */
    void **ptr_to_old_ebp = newptr; /* перед pop rbp указатель стека должен указывать на старый rbp.
                                       Откуда берется указатель стека? mov rsp, rbp (см. описание leave выше).
                                       Запомним это значение и позже занесем в rbp. */

    /* Скучная часть. Функция yield сохраняет в стек и затем восстанавливает значения основных регистров.
     * Т.к. мы попадаем в середину функции yield (где начинается восстановление),
     * нужно заполнить стек, чтобы было из чего восстанавливать.
     *
     * Сами значения нам не важны, т.к. далее мы попадаем в coro, где регистры перезапишутся.
     * Главное, чтобы число записываемых значений и восстанавливаемых регистров совпадало.
     */
    *(--newptr) = (void *)1; 
    *(--newptr) = (void *)2; 
    *(--newptr) = (void *)3; 
    *(--newptr) = (void *)4; 
    *(--newptr) = (void *)5; 
    *(--newptr) = (void *)6; 
    *(--newptr) = (void *)7; 
    *(--newptr) = (void *)8; 
    *(--newptr) = (void *)9; 
    *(--newptr) = (void *)10; 
    *(--newptr) = (void *)11; 
    *(--newptr) = (void *)12; 
    *(--newptr) = (void *)13; 
    *(--newptr) = (void *)14; 
    
    /* отлично, стек готов. */

    struct taskstate *newtask = malloc(sizeof(struct taskstate));
    newtask->rsp = (char *)(newptr);  /* rsp указывает на вершину только что подготовленного стека */
    newtask->rbp = (char *)(ptr_to_old_ebp); /* выше обсуждалось зачем мы это делаем */
    newtask->allocated_stack = newstackbase; /* запомним адрес выделенного под стек блока, чтобы потом освободить */
    /* Вставим сопрограмму в список, так, чтобы она выполнилась следующей при очередном yield */
    newtask->next = __current_task->next;
    __current_task->next = newtask;
}


/* Переключение на следующую сопрограмму.
 *
 * Единственное место где используется ассемблер, делающий эту штуку непортабельной.
 * Но переписать код под другой процессор должно быть просто.
 *
 * */
void yield() {
    /* Запомним состояние основных регистров в стеке текущей сопрограммы */
    asm volatile (
                 "push %%rax ; \r\n"  
                 "push %%rbx ; \r\n"  
                 "push %%rcx ; \r\n"  
                 "push %%rdx ; \r\n"  
                 "push %%rdi ; \r\n"  
                 "push %%rsi ; \r\n"  
                 "push %%r8  ; \r\n"  
                 "push %%r9  ; \r\n"  
                 "push %%r10 ; \r\n"  
                 "push %%r11 ; \r\n"  
                 "push %%r12 ; \r\n"  
                 "push %%r13 ; \r\n"  
                 "push %%r14 ; \r\n"  
                 "push %%r15 ; \r\n"  
                 "mov $__current_task, %%rsi; \r\n" /* запомним состояние стека текущей сопрограммы
                                                       в дескрипторе */
                 "mov 0x0(%%rsi), %%rbx; \r\n"
                 "mov %%rsp, 0x0(%%rbx); \r\n"
                 "mov %%rbp, 0x8(%%rbx); \r\n"
                 : : :
    );

    /* переключимся на дескриптор следующей сопрограммы */
    __current_task = __current_task->next;

    /* <--- при первом выполнении новой сопрограммы мы попадаем в это место!! */

    asm volatile (
                 "mov $__current_task, %%rsi; \r\n" /* восстановим стек сопрограммы, на которую переключились */
                 "mov 0x0(%%rsi), %%rbx; \r\n"
                 "mov 0x0(%%rbx), %%rsp; \r\n"
                 "mov 0x8(%%rbx), %%rbp; \r\n"
                 "pop %%r15 ; \r\n"                 /* восстановим состояние основных регистров */
                 "pop %%r14 ; \r\n"  
                 "pop %%r13 ; \r\n"  
                 "pop %%r12 ; \r\n"  
                 "pop %%r11 ; \r\n"  
                 "pop %%r10 ; \r\n"  
                 "pop %%r9  ; \r\n"  
                 "pop %%r8  ; \r\n"  
                 "pop %%rsi ; \r\n"  
                 "pop %%rdi ; \r\n"  
                 "pop %%rdx ; \r\n"  
                 "pop %%rcx ; \r\n"  
                 "pop %%rbx ; \r\n"  
                 "pop %%rax ; \r\n"  
                 : : :
                );
    /* Все! После выхода из yield() сопрограмма, на которую мы сейчас переключились, продолжит выполняться. */
}

/* Инициализация списка сопрограмм */
void coroutine_init() {
    __current_task = malloc(sizeof(struct taskstate));
    __current_task->next = __current_task;
    __current_task->allocated_stack = NULL;
}

/* Диспетчер.
 * Сам по сути является сопрограммой.
 * Ему в списке сопрограмм соответствует дескриптор, вставленный функцией coroutine_init.
 *
 * Роль диспетчера - ничего не делать до тех пор, пока он не останется последней сопрограммой.
 */
void coroutine_mainloop() {
    do {
        yield();
    } while (__current_task->next != __current_task);
}

/* Пример сопрограммы №1 */
void my_coro_0 () {
    printf("Hello 0\n");
    yield();
    printf("Hello 1\n");
    yield();
    printf("Hello 2\n");
    yield();
    printf("Coro 0 Dying\n");
}

/* Пример сопрограммы №2 */
void my_coro_1 () {
    printf("Salut 0\n");
    yield();
    printf("Salut 1\n");
    yield();
    printf("Salut 2\n");
    yield();
    printf("Coro 1 Dying\n");
}

int main() {
    coroutine_init();
    coroutine_schedule(my_coro_0);
    coroutine_schedule(my_coro_1);
    coroutine_mainloop();
    printf("/main\n");
    return 0;
}
